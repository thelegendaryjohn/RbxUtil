"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2574],{38162:n=>{n.exports=JSON.parse('{"functions":[{"name":"spawn","desc":"Spawns the function using `task.spawn`.\\n\\n```lua\\nlocal c = Concur.spawn(function()\\n\\ttask.wait(5)\\n\\treturn \\"Hello!\\"\\nend)\\n\\nc:OnCompleted(function(err, msg)\\n\\tif err then\\n\\t\\terror(err)\\n\\tend\\n\\tprint(msg) --\x3e Hello!\\nend))\\n```","params":[{"name":"fn","desc":"","lua_type":"AnyFn"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Concur\\n"}],"function_type":"static","source":{"line":100,"path":"modules/concur/init.luau"}},{"name":"defer","desc":"Same as `Concur.spawn`, but uses `task.defer` internally.","params":[{"name":"fn","desc":"","lua_type":"AnyFn"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Concur\\n"}],"function_type":"static","source":{"line":110,"path":"modules/concur/init.luau"}},{"name":"delay","desc":"Same as `Concur.spawn`, but uses `task.delay` internally.","params":[{"name":"delayTime","desc":"","lua_type":"number"},{"name":"fn","desc":"","lua_type":"AnyFn"},{"name":"...","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Concur\\n"}],"function_type":"static","source":{"line":120,"path":"modules/concur/init.luau"}},{"name":"value","desc":"Resolves to the given value right away.\\n\\n```lua\\nlocal val = Concur.value(10)\\nval:OnCompleted(function(v)\\n\\tprint(v) --\x3e 10\\nend)\\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"Concur\\n"}],"function_type":"static","source":{"line":139,"path":"modules/concur/init.luau"}},{"name":"event","desc":"Completes the Concur instance once the event is fired and the predicate\\nfunction returns `true` (if no predicate is given, then completes once\\nthe event first fires).\\n\\nThe Concur instance will return the values given by the event.\\n\\n```lua\\n-- Wait for next player to touch an object:\\nlocal touch = Concur.event(part.Touched, function(toucher)\\n\\treturn Players:GetPlayerFromCharacter(toucher.Parent) ~= nil\\nend)\\n\\ntouch:OnCompleted(function(err, toucher)\\n\\tprint(toucher)\\nend)\\n```","params":[{"name":"event","desc":"","lua_type":"RBXScriptSignal"},{"name":"predicate","desc":"","lua_type":"((...any) -> boolean)?"}],"returns":[],"function_type":"static","source":{"line":163,"path":"modules/concur/init.luau"}},{"name":"all","desc":"Completes once _all_ Concur instances have been completed. All values\\nwill be available in a packed table in the same order they were passed.\\n\\n```lua\\nlocal c1 = Concur.spawn(function()\\n\\treturn 10\\nend)\\n\\nlocal c2 = Concur.delay(0.5, function()\\n\\treturn 15\\nend)\\n\\nlocal c3 = Concur.value(20)\\n\\nlocal c4 = Concur.spawn(function()\\n\\terror(\\"failed\\")\\nend)\\n\\nConcur.all({c1, c2, c3}):OnCompleted(function(err, values)\\n\\tprint(values) --\x3e {{nil, 10}, {nil, 15}, {nil, 20}, {\\"failed\\", nil}}\\nend)\\n```","params":[{"name":"concurs","desc":"","lua_type":"{ Concur }"}],"returns":[{"desc":"","lua_type":"Concur\\n"}],"function_type":"static","source":{"line":215,"path":"modules/concur/init.luau"}},{"name":"first","desc":"Completes once the first Concur instance is completed _without an error_. All other Concur\\ninstances are then stopped.\\n\\n```lua\\nlocal c1 = Concur.delay(1, function()\\n\\treturn 10\\nend)\\n\\nlocal c2 = Concur.delay(0.5, function()\\n\\treturn 5\\nend)\\n\\nConcur.first({c1, c2}):OnCompleted(function(err, num)\\n\\tprint(num) --\x3e 5\\nend)\\n```","params":[{"name":"concurs","desc":"","lua_type":"{ Concur }"}],"returns":[{"desc":"","lua_type":"Concur\\n"}],"function_type":"static","source":{"line":259,"path":"modules/concur/init.luau"}},{"name":"Stop","desc":"Stops the Concur instance. The underlying thread will be cancelled using\\n`task.cancel`. Any bound `OnCompleted` functions or threads waiting with\\n`Await` will be completed with the error `Concur.Errors.Stopped`.\\n\\n```lua\\nlocal c = Concur.spawn(function()\\n\\tfor i = 1,10 do\\n\\t\\tprint(i)\\n\\t\\ttask.wait(1)\\n\\tend\\nend)\\n\\ntask.wait(2.5)\\nc:Stop() -- At this point, will have only printed 1 and 2\\n```","params":[],"returns":[],"function_type":"method","source":{"line":310,"path":"modules/concur/init.luau"}},{"name":"IsCompleted","desc":"Check if the Concur instance is finished.","params":[],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"method","source":{"line":325,"path":"modules/concur/init.luau"}},{"name":"Await","desc":"Yields the calling thread until the Concur instance is completed:\\n\\n```lua\\nlocal c = Concur.delay(5, function()\\n\\treturn \\"Hi\\"\\nend)\\n\\nlocal err, msg = c:Await()\\nprint(msg) --\x3e Hi\\n```\\n\\nThe `Await` method can be called _after_ the Concur instance\\nhas been completed too, in which case the completed values\\nwill be returned immediately without yielding the thread:\\n\\n```lua\\nlocal c = Concur.spawn(function()\\n\\treturn 10\\nend)\\n\\ntask.wait(5)\\n-- Called after \'c\' has been completed, but still captures the value:\\nlocal err, num = c:Await()\\nprint(num) --\x3e 10\\n```\\n\\nIt is always good practice to make sure that the `err` value is handled\\nby checking if it is not nil:\\n\\n```lua\\nlocal c = Concur.spawn(function()\\n\\terror(\\"failed\\")\\nend)\\n\\nlocal err, value = c:Await()\\n\\nif err ~= nil then\\n\\tprint(err) --\x3e failed\\n\\t-- Handle error `err`\\nelse\\n\\t-- Handle `value`\\nend\\n```\\n\\nThis will stop awaiting if the Concur instance was stopped\\ntoo, in which case the `err` will be equal to\\n`Concur.Errors.Stopped`:\\n\\n```lua\\nlocal c = Concur.delay(10, function() end)\\nc:Stop()\\nlocal err = c:Await()\\nif err == Concur.Errors.Stopped then\\n\\tprint(\\"Was stopped\\")\\nend\\n```\\n\\nAn optional timeout can be given, which will return the\\n`Concur.Errors.Timeout` error if timed out. Timing out\\ndoes _not_ stop the Concur instance, so other callers\\nto `Await` or `OnCompleted` can still grab the resulting\\nvalues.\\n\\n```lua\\nlocal c = Concur.delay(10, function() end)\\nlocal err = c:Await(1)\\nif err == Concur.Errors.Timeout then\\n\\t-- Handle timeout\\nend\\n```","params":[{"name":"timeout","desc":"","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"Error"},{"desc":"","lua_type":"...any?"}],"function_type":"method","yields":true,"source":{"line":402,"path":"modules/concur/init.luau"}},{"name":"OnCompleted","desc":"Calls the given function once the Concur instance is completed:\\n\\n```lua\\nlocal c = Concur.delay(5, function()\\n\\treturn \\"Hi\\"\\nend)\\n\\nc:OnCompleted(function(err, msg)\\n\\tprint(msg) --\x3e Hi\\nend)\\n```\\n\\nA function is returned that can be used to unbind the function to\\nno longer fire when the Concur instance is completed:\\n\\n```lua\\nlocal c = Concur.delay(5, function() end)\\nlocal unbind = c:OnCompleted(function()\\n\\tprint(\\"Completed\\")\\nend)\\nunbind()\\n-- Never prints \\"Completed\\"\\n```\\n\\nThe `OnCompleted` method can be called _after_ the Concur instance\\nhas been completed too, in which case the given function will be\\ncalled immediately with the completed values:\\n\\n```lua\\nlocal c = Concur.spawn(function()\\n\\treturn 10\\nend)\\n\\ntask.wait(5)\\n-- Called after \'c\' has been completed, but still captures the value:\\nc:OnCompleted(function(err, num)\\n\\tprint(num) --\x3e 10\\nend)\\n```\\n\\nIt is always good practice to make sure that the `err` value is handled\\nby checking if it is not nil:\\n\\n```lua\\nlocal c = Concur.spawn(function()\\n\\terror(\\"failed\\")\\nend)\\n\\nc:OnCompleted(function(err, value)\\n\\tif err ~= nil then\\n\\t\\tprint(err) --\x3e failed\\n\\t\\t-- Handle error `err`\\n\\t\\treturn\\n\\tend\\n\\t-- Handle `value`\\nend)\\n```\\n\\nThis will call the function if the Concur instance was stopped\\ntoo, in which case the `err` will be equal to\\n`Concur.Errors.Stopped`:\\n\\n```lua\\nlocal c = Concur.delay(10, function() end)\\nc:OnCompleted(function(err)\\n\\tif err == Concur.Errors.Stopped then\\n\\t\\tprint(\\"Was stopped\\")\\n\\tend\\nend)\\nc:Stop()\\n```\\n\\nAn optional timeout can also be supplied, which will call the\\nfunction with the `Concur.Errors.Timeout` error:\\n\\n```lua\\nlocal c = Concur.delay(10, function() end)\\nc:OnCompleted(function(err)\\n\\tif err == Concur.Errors.Timeout then\\n\\t\\t-- Handle timeout\\n\\tend\\nend, 1)\\n```","params":[{"name":"fn","desc":"","lua_type":"(Error, ...any?) -> ()"},{"name":"timeout","desc":"","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"() -> ()\\n"}],"function_type":"method","source":{"line":517,"path":"modules/concur/init.luau"}}],"properties":[{"name":"Errors","desc":"","lua_type":"Errors","readonly":true,"source":{"line":49,"path":"modules/concur/init.luau"}}],"types":[{"name":"Errors","desc":"","fields":[{"name":"Stopped","lua_type":"\\"Stopped\\"","desc":""},{"name":"Timeout","lua_type":"\\"Timeout\\"","desc":""}],"source":{"line":43,"path":"modules/concur/init.luau"}}],"name":"Concur","desc":"Concurrency class for helping run tasks concurrently. In other words, Concur allows\\ndevelopers to watch coroutines/threads. Completion status, returned values, and\\nerrors can all be tracked.\\n\\nFor instance, Concur could be used to concurrently save all player data\\nat the same time when the game closes down:\\n\\n```lua\\ngame:BindToClose(function()\\n\\tlocal all = {}\\n\\tfor _,player in Players:GetPlayers() do\\n\\t\\tlocal save = Concur.spawn(function()\\n\\t\\t\\tDoSomethingToSaveData(player)\\n\\t\\tend)\\n\\t\\ttable.insert(all, save)\\n\\tend\\n\\tlocal allConcur = Concur.all(all)\\n\\tallConcur:Await()\\nend)\\n```","source":{"line":34,"path":"modules/concur/init.luau"}}')}}]);